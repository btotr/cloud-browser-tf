<!DOCTYPE html>
<html>
  <head>
    <title>Cloud Browser Architecture</title>
    <meta charset='utf-8'>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' async class='remove'></script>
    <script class='remove'>
      var respecConfig = {
          specStatus:         "IG-NOTE",
          shortName:          "cloud-browser-arch",
          editors:  [
              {
                  name:       "Colin Meerveld",
                  mailto:     "c.meerveld@activevideo.com",
                  company:    "Activevideo",
                  companyURL: "http://www.activevideo.com/"
              },
              {
                  name:       "Alexandra Mikityuk", 
                  mailto:     "Alexandra.Mikityuk@telekom.de",
                  company:    "Deutsche Telekom",
                  companyURL: "http://www.telekom.com"
              }
          ],
          wg:                 "Web and TV Interest Group",
          wgURI:              "https://www.w3.org/2011/webtv/",
          wgPublicList:       "public-web-and-tv@w3.org",
          charterDisclosureURI: "https://www.w3.org/2017/03/webtv-charter.html"

      };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
          A Cloud Browser is a browser running and executing on a server. This document describes the concepts and architecture for the Cloud Browser. The main purpose is to provide the building blocks for a Cloud Browser solution.
      </p>
    </section>
    
    <section id='sotd'>
      <p>
          This is an Interest Group Note that the Cloud Browser Task Force of the Web and TV Interest Group is discussing and exploring. It has no official standing of any kind and does not represent the support or consensus of any standard organisations or contributors. This is a subset of the W3C Public Web &amp; TV Interest Group - Cloud Browser Task Force. As the Cloud Browser TF progresses its work, this section will be used to identify the architecture that has reached rough consensus within the group.
      </p>
      <p>
          The group have been working on various use cases of the Cloud Browser mechanism, and this "Cloud Browser Architecture Note" was originally a part of that discussion.  Note that the group have been working on the survey of exisiting similar mechanisms, and the group's basic plan is publishing the following three topics as three separate IG Notes first and then merge them into one consolidated Note later:
      </p>
      <ol>
      <li>Basic architecture (this "Cloud Browser Architcture" IG Note)</li>
      <li><a href="https://www.w3.org/2011/webtv/wiki/Main_Page/Cloud_Browser_TF/cloud_browser_vs_split_browser">Survey of the prior work (similarity/difference)</a></li>
      <li><a href="https://www.w3.org/2011/webtv/wiki/Main_Page/Cloud_Browser_TF/UseCases">Use cases and requirements</a></li>
      </ol>

      <p>
          It would take some more time to finalize the <a href="https://www.w3.org/2011/webtv/wiki/Main_Page/Cloud_Browser_TF/cloud_browser_vs_split_browser">survey of the prior work</a> and the <a href="https://www.w3.org/2011/webtv/wiki/Main_Page/Cloud_Browser_TF/UseCases">Use cases and requirements</a>.
      However, the group would like to start to get wider review and comments from the public for the basic architectural mechanism first.
    </section>
    
    <section>
      <h2>Introduction</h2>
      <p>
         The web becomes a feature rich platform. Media capturing, web workers, and many other features ensure an engaging web experience. The increase of features impacts the hardware resources. Provide the same experience to a variety of devices is difficult; therefore, the industry is shifting to another model. Leading content providers will not use a general web browser anymore; instead, a customised web browser is used. Some only use a subset of the web specifications. Some create their own proprietary language. Others will implement a native javascript framework. This assures (near) the same experience on each device and doesn't have to bother with the device varieties. 
      </p>
      <p>
        Several web browsers, on a single device, is not desirable. It causes fragmentation and uses client device resources; not a durable solution. The Cloud Browser addresses these issues by putting the browser into a powerful server, or cloud. The execution is shifted to the cloud, where the user interface is rendered and send to the Client Device. The main purpose of the client device is presenting the user interface to the end user. This solution makes it possible to provide a uniform experience for a large range of devices. Furthermore, it reduces the need for processing on the client device and helps to deploy new browser technologies faster.
      </p>
      <p>
        A great number of users are experiencing the Cloud Browser technology today. The concept of a Cloud Browser is never defined as standardised work; differences with traditional client server model are not explored. This group note is a joined effort from the Cloud Browser Task Force. It provides requirements, use cases and a formalised architecture of a Cloud Browser.
      <p>
    <section>    
      <h3>Cloud Browser compared to a local browser</h3>
      <p>
        Most people are familiar with local browsers. A content server serves resources such as HTML, Javascript, and media. The local browser requests the resources and makes it perceivable for the end-user. The local browser exists in the operating system. Starting and stopping the browser is the responsibility of the operating system. In addition, it provides hardware functionality such as keyboard inputs. A Cloud Browser differ in varies aspects:
      </p>
      <ul>
        <li>An operating system or desktop environment is not interacting with the web browser.</li>
        <li>Execution is done on the server but the user interface is displayed on a client device.</li>
        <li>The client device isn't constraint by resources such as memory or CPU.</li>
        <li>The Cloud Browser isn't directly connected to the Client Device hardware.</li>
      </ul>
    </section>
    <section>    
      <h3>Cloud Browser compared with a split browser</h3>
      <p>
        A split browser, or transformation proxy, transform the content to the most appropriate format for the client device. The Cloud Browser is comparable but different. 
      </p>
      <ul>
        <li>Split browsers provide the best possible representation but are limited by the client capabilities. The split browser could optimise the content but the client needs to process the content. A Cloud Browser terminates everything on the server; therefore, circumvent this problem.</li>
        <li>The Cloud Browser exists in the cloud. The initiator or client device is only triggering events but is not responsible for the resources nor the representation.</li>
        <li>A Split browser "transforms" the content. The Cloud Browser acts as a local browser; therefore, don't alter the content.</li>
      </ul>
    </section>
    <section>    
      <h3>Cloud Browser compared with a thin/fat paradigm</h3>
      <p>
        In a thin/fat paradigm, all processing is done on the server and the user interface is provided to a thin- or zero-client. The Cloud Browser is very comparable but has three key differences: 
      </p>
      <ul>
        <li>In a thin/fat paradigm, there are dependencies on an underlying operating system. The Cloud Browser only provides the web browser without dependencies.</li>
        <li>The Cloud Browser may complement web features, virtually.</li>
        <li>The Cloud Browser leverage client capabilities where applicable.</li>
      </ul>
    </section>
    <section>
      <h2>Terminology</h2>
      <dt>Cloud Browser Client</dt>
      <dd>Program which communicates with the orchestration.</dd>
      <dt>Client Device</dt>
      <dd>Actual hardware which is running the cloud browser client.</dd>
      <dt>Cloud Browser</dt>
      <dd>User agent terminated in the orchestration.</dd>
      <dt>Orchestration</dt>
      <dd>Server which abstracts functionality and manages sessions for the cloud browser.</dd>
      <dt>Media Server</dt>
      <dd>A generalised term for an infrastructure which provide various media streams such as VoD, linear broadcast and even a local pvr.</dd>
      <dt>Graphics Library</dt>
      <dd>A library responsible for rendering graphics to the end-user.</dd>
      <dt>Out-of-band media</dt>
      <dd>Media that is delivered to the Cloud Browser Client from Media Server directly.</dd>
      <dt>Web Application</dt>
      <dd>A software program running in a web browser.</dd>
      <dt>Cloud Browser Server</dt>
      <dd>The server where the Cloud Browser is hosted and executed.</dd>
      <dt>Transformation Proxy</dt>
      <dd>Transformation proxies alter requests sent by user agents to servers and responses returned by servers so that the appearance, structure or control flow of Web applications are modified.</dd>
    </section>

    <section>
      <h2>Architecture</h2>
      <p>
          The Cloud Browser Architecture is provided in the following section. The goal is to have a consistent architecture between Cloud Browser vendors.
      </p>
      <section>
        <h4>Client Device</h4>
        <p>
            A Client Device is a apparatus where the user interface is presented. The Client Device needs to be connected.  A Client Device could be A Set-Top-Box. A Client Device could be a mobile phone. A Client Device could even be a smart watch. Provided that a Cloud Browser Client is available. 
        </p>
      </section>
      <section>
        <h4>Cloud Browser Client</h4>
        <p>
            In a Cloud Browser solution, the execution is done in the cloud; the result is sent to the Cloud Browser Client. This Cloud Browser Client is only responsible for showing the user interface and providing essential information such as key strokes. The latter is depending on the infrastructure. It will be transport and format agnostic. In other words, it will be vendor specific or may be standardised in the future. The Cloud Browser Client doesn't have any context. It connects to the orchestration and shows the user interface. This will make sure that all the logic is in the cloud, and avoid, otherwise required updates, on the Client Device. A way to visualise the Cloud Browser Client is a remote display which sends essential information to the Cloud Browser Orchestration.
        </p>
      </section>  
      <section>
        <h4>Cloud Browser</h4>
        <p>
         The Cloud Browser denoted in the architecture is a web browser instance, terminated in the orchestration. It acts as a local web browser. Consequently, existing Web Application doesn't have to be authored for a Cloud Browser Solution.
        </p>
      </section>  
      <section>
        <h4>Orchestration</h4>
        <p>
          The Cloud Browser exists in an orchestration that is responsible for session management and abstraction. Multiple Cloud Browsers Clients could connect to the orchestration. The orchestration makes sure a client connects to the right Cloud Browser instance. Furthermore, any difference with a local browser is abstracted. For example, a Client Device may have constraints on codec capabilities. By abstracting those constraints the orchestration could either provide this to a W3C standardized API or virtually enhance this constraint by transcoding to a supported codec. Either way, the Cloud Browser is unaware of the decisions. This typical example ensures that the Client Device could run any Web Application, regardless of the codec it mandates. In which manner the orchestration is abstracted is out of scope for this document, and up to the implementor.
        </p>
        <p>
          The orchestration receives triggers from the Cloud Browser Client such as key strokes originated from the remote control. Triggers are not restricted to input. It could be any information from the Client Device. The orchestration interpreted the triggers and may decide to delegate it to the Cloud Browser. Depending on the context a red button could be process as a regular key press by the Cloud browser or opens a new Web Application on a certain URL. 
        </p>
        <p>
          The orchestration decides how the user interface is sent to the Cloud Browser Client. There are two main approaches, a Single Stream and a Double Stream approach. The stream format is agnostic to the architecture because this encourages innovation.
        </p>
      </section>
    </section>      
    
    <section>
      <h5 id="single-stream">Single Stream</h5>  
      <p>
          In the Single Stream approach, the orchestration provides both, the user interface and the media streams.
      </p>
      <figure>
        <img src="https://www.w3.org/2011/webtv/wiki/images/0/0c/Ss-cp-highlevel.png" alt="">
        <figcaption>Architecture single stream</figcaption>
      </figure>
      <p>
        This approach executes the Web Application in the Cloud Browser and delivers the user interface to the Cloud Browser Client. A typical use case: the user starts the Client Device. The Cloud Browser Client triggers a signal. The signal is received and resolved in the orchestration. It delegates further processing to the Cloud Browser. The Cloud Browser request, download, and parse the resources. These resources include HTML, CSS, and JavaScript. JavaScript is processed and executed. User Interface painting commands are sent to the Graphic Library.
      <p>
      </p>
        In case the Web Application requests a media stream from a Media Server. The Graphic Library will combine the media stream together with the User Interface. The Orchestration sent a single media stream to the Cloud Browser Client; encoded by a Client Device supported codec. The Cloud Browser Client decode and present the stream to the Client Device display.
      </p>
    </section>
     <section>  
      <h5 id="double-stream">Double Stream</h5>  
      <p>
          With a Double Stream approach, the Cloud Browser renders the user interface only, while the media is delivered from another source. The User Interface and media streams are delivered separately to the Client Device, which then has to combine both of these streams. The Cloud Browser Client present them to the end-user in a unified form. This approach leverages the video delivery infrastructures. A typical example of a delivery infrastructure is broadcast networks. Here the media is sent to all receivers at ones. Rerouting the traffic is not desired.</p>
      <figure>
        <img src="https://www.w3.org/2011/webtv/wiki/images/e/e3/Ds-lp-highlevel.png" alt="">
        <figcaption>Architecture Double Stream</figcaption>
      </figure>
    </section>
    <section>
      <p>
        This approach executes the Web Application and delivers the User Interface to the Cloud Browser Client as the single stream approach. A media stream is delivered Out Of Band from another source. Blending is done on the Cloud Browser Client. The user interface is usually provided as a sequence of images which a Client Device could process within its own Graphic Library.</p>
    </section>
    <section>
      <h2>Use Cases</h2>
      <p>
         Cloud Browser Use Cases are split into two categories. Communication and execution.
      </p>
    </section>
    <section>
      <h3>Communication uses cases</h3>
      <p>
        Enabling a Cloud Browser solution will need communication between a Cloud Browser Client and the Orchestration. Outcomes from these use cases will lead to new standards.
      </p>
    </section>
    
    <section>
      <h4>Cloud Browser Client establishes a control channel with the Cloud Browser</h4>

      <p>
        The control channel is used to communicate the state of the Cloud Browser Client to the Cloud Browser, receive requests from the Cloud Browser.
      </p>
      <ol>
        <li>Cloud Browser Client connects to the Orchestration.</li>
        <li>Cloud Browser Client authenticates itself to the Cloud Orchestration.</li>
        <li>If the authentication is successful, the Orchestration connects the Cloud Browser with the client through the control channel.</li>
      </ol>
      <section>    
        <h5>Requirements</h5>
        <ul>
          <li>The control channel must be reliable; so, that no state change or instruction gets lost.</li>
          <li>Both the Cloud Browser and the Cloud Browser Client communicate through this channel.</li>
          <li>Cloud environment needs a way to authenticate the client.</li>
        </ul>
      </section>
    </section>  
    <section>
      <h4>Cloud Browser sends request through control channel to the Cloud Browser Client</h4>

      <p>
        The application running within the Cloud Browser issues an API call, this API call depends upon the partial or whole execution in the Cloud Browser Client.
      </p>
      <ol>
        <li>Application issues API call.</li>
        <li>Cloud Browser begins executing the API call.</li>
        <li>If a part or the whole call depends on the client side execution, then send a request to the device client.</li>
        <li>Client processes the request and sends the result back to the Cloud Browser (if necessary).</li>
        <li>Cloud Browser goes on with the execution of the API call.</li>
      </ol>
      <section>    
        <h5>Notes</h5>
        <p>
          If the API call is synchronous then the request has to be synchronous too.
        </p>
        <p>
          List of possible requests:        
          <ul>
            <li>Set the volume.</li>
            <li>Load an URL for playback (for Double Stream Approach with a local player).</li>
            <li>Play, pause, stop, seek current playing media.</li>
            <li>Control client local tuner.</li>
          </ul>
        </p>
      </section>
      <section>    
        <h5>Requirements</h5>
        <ul>
          <li>There must be a control channel.</li>
          <li>All communication must be validated, to make sure that no malicious data has been inserted.</li>
        </ul>
      </section>
    </section>
    
    <section>
      <h3>Execution Use Cases</h3>
      <p>
        Execution Use Cases describe the challenges that the Cloud Browser encounter. Some use cases will work on a local browser but are problematic on a Cloud Browser. These use cases will be used to extend or modify existing standards.
      </p>
    </section>
    
    <section>
      <h4>User interface is downscaled on the client device.</h4>

      <p>As a Web Application, I would like to know how the User Interface is perceived by the end-user.</p>
      <ol>
        <li>The cloud browser renders the User Interface on 1920x1080 resolution.</li>
        <li>The client is only capable of displaying 1280x720.</li>
        <li>Cloud Browser downscale the User Interface to 1280x720.
      </ol>
      <p>
        Typical example: the user interface is specifically authored for a higher resolution. The screen properties provide the same resolution but the scale is changed.
      </p>
      <section>    
        <h5>Notes</h5>
        <p>
          A workable solution is to look at the devicePixelRatio on the window object (window.devicePixelRatio). However, this is not how the   property is used today. 
        </p>
      </section>  
      <section>  
        <h5>Requirements</h5>
        <p>
          There should be means to see how the end user perceives the User Interface.
        </p>
      </section>
    </section>  
    <section>    
      <h4>Application needs to know when the User Interface is visible</h4>
      <h3>Description</h3>
      <p>
        As an application, I would like to know when the User Interface is perceived by the end-user
      </p>
      <ol>
        <li>The cloud browser renders the User Interface.</li>
        <li>DOM loaded event is fired.</li>
        <li>The client receives the User Interface and renders it to the end user.</li>
      </ol>
      <h5>Notes</h5>
      <p>
        Since the UI is terminated in the cloud, it is hard to tell when the user actually sees it. On a local browser this instantaneously   after a load event. However, on a cloud solution, the UI needs to be sent to the Client Device. Depending on the network   infrastructure (broadband, managed IP) it could take up a significant amount of time. Therefore, you need to use the rendered event   which reflects the time the user perceives the UI.
      </p>
      </section>
      <section>  
        <h5>Requirement</h5>
        <p>
          There should be means to see when the end user perceives the User Interface. A solution could be to have an additional event to notify   when the User Interface is rendered on the screen
        </p>
      </section>
    </section>  
    <section>    
      <h4>Application needs to virtual media capabilities</h4>

      <p>
        As a Web Application, I would like to know which media capabilities are virtual and which are native
      </p>
      <ol>
        <li>The cloud browser request media capabilities.</li>
        <li>Cloud Browser provides both virtual as-well as native capabilities.</li>
        <li>As a content provider, you would like to serve the best possible content the users could perceive on their device.</li>
      </ol>
      <section>    
        <h5>Notes</h5>
        <p>
          The canPlayType property may be used to detect the supported types. However, on a cloud browser solution, you would also like to know   which types are played natively on the client device and which are transcoded. Apart from additional processing cost on the server,   it would make more sense to play a media asset natively and leverage the device capabilities when possible.
        </p>
      </section>
      <section>    
        <h5>Requirements</h5>
        <p>
          There should be a way to identify virtual and native media capabilities. A solution could be to look at the the "virtually" type with   the canPlayType. Here is an example how it will look:
            <code>
              var support = videoElement.canPlayType('type=\'video/mp4; codecs="avc1.42E01E, mp4a.40.2"\); 
              if (support == "probably") console.log("natively supported") 
              else if (support == "virtually") console.log("supported by transcoding")
            </code>
        </p>
      </section>
    </section>  
    <section>
      <h4>Application needs to know how to identify</h4>

      <p>
        As a Web Application, I would like to know how to interpreted identification      
      </p>
      <ol>
        <li>The Cloud Browser request geolocation.</li>
        <li>Cloud Browser provides location of the orchestration.</li>
      </ol>
      <section>        
        <h5>Notes</h5>
        <p>
          Sometimes it could be confusing what part is identified. For example, the geolocation API could be used to identify from which   location the user is interacting. Based on this information different content could be served. However, it should be clear that the   locations are based on the user location and not the cloud browser. This will also provide incorrect inside into analytic services.   Usually, the services are using the IP address as the reference which may not work with a Cloud Browser.
        </p>
      </section>
      <section>    
        <h5>Requirement</h5>
        <p>
          There should be a convention how to interpreted identification APIs. Where possible a Cloud Browser solution could provide an x  -forwarded-for HTTP header. The client type information could be obtained by the user agent string together with the Orchestration   information.
        </p>
      </section>
    </section>  
    <section>  
      <h4>Application needs to have additional error handling</h4>

      <p>
        As a Web Application, I would like to know how to provide Cloud Browser specific errors
      </p>
      <ol>
        <li>The client generates a decode error</li>
        <li>Cloud Browser provides error to the application</li>
      </ol>  

      <section>    
        <h5>Notes</h5>
        <p>
          In a Cloud Browser, you may need additional error reporting. For example when something goes wrong between the Cloud Browser and   Client Device you need to have feedback what went wrong.
        </p>
      </section>
      <section>    
        <h5>Requirements</h5>
        <p>
          There needs to be a way to provide Cloud Browser specific errors. A proper error message may be reported in the global window object   using the error event.
        </p>  
      </section>
    </section>  
    <section>
      <h3>Acknowledgments</h3>
      <p>
        Special thanks to Oliver Friedrich, Nilo Mitra, Kaz Ashimura and Steve Morris for there contributions to this document.
      </p>
    </section>
  </body>
</html>